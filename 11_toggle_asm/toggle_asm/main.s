//* one file blink and toggle button program *
#include <avr/io.h>

.EQU LED_alive , 7
.EQU LED0 , 0
.EQU LED1 , 1
.EQU KEY0 , 4 ; note that "KEY0: is on the 4th PIN!
.EQU KEY1 , 5


.DATA
led_status:
.BYTE 1
key_last:
.BYTE 1


; main program function starts here
.GLOBAL main
.TEXT
main:

main_initialize:
    ; Optional: zero portA contents to prevent LED flickering during this setup
    eor     R16,                        R16 ; or  ldi R16, 0
    out     _SFR_IO_ADDR(PORTA),        R16
    ; Using PortA, Pin7 and Pin0 as outputs
    ldi     R16,                        (1<<LED_alive | 1<<LED0)
    ; Note: if random other LEDs are one, set all connected PINs to output mode - ldi R16, 0xFF
    out     _SFR_IO_ADDR(DDRA),         R16

    ; Reassuring that PortE pin 4 PINB is set as an input with pull up resistors
    ldi     R16,                        0
    out     _SFR_IO_ADDR(DDRE),         R16         ; sets all pins as IN
    ldi     R16,                        1<<KEY0
    out     _SFR_IO_ADDR(PORTE),        R16         ; activates pull up resistors on used pins

    ; Initialize variables and registers
    ldi     R16,                        0
    sts     led_status,                 R16
    sts     key_last,                   R16

main_superloop:
    ldi     R17,        1<<LED_alive
    lds     R16,        led_status
    eor     R16,        R17
    sts     led_status, R16

    in      R16,        _SFR_IO_ADDR(PINE)
    lds     R18,        key_last
    eor     R18,        R16
    sts     key_last,   R16

check_b0:
    mov     R16,        R18
    andi    R16,        1<<KEY0
    breq    skip_b0
    lds     R16,        key_last
    andi    R16,        1<<KEY0
    breq    skip_b0
toggle_led0:
    ldi     R17,        1<<LED0
    lds     R16,        led_status
    eor     R16,        R17
    sts     led_status, R16
skip_b0:


    lds     R16,        led_status
    out     _SFR_IO_ADDR(PORTA),    R16

    ; call delay function with number of MS in R3
    ldi     R16,        100
    mov     R3,         R16
    rcall   delay_in_ms

    ; and go back to repeat everything forever
    rjmp    main_superloop



; this function
;   - receives a unit8_t  variable in register [r3]
;   - causes time delay of that many milliseconds by wasting time and energy
;   - returns 0 in [r3]
;
.GLOBAL delay_in_ms

.EQU OneMS, (16*1000/5) ; == 3072
             ; 16MHz clock yields 16,0000 instructions per one millisecond
                   ; each loop iteration takes five instructions to execute

.TEXT
delay_in_ms:
    push    R16
    in      R16,        _SFR_IO_ADDR(SREG)
    push    R16

    push    R17
    push    R18
    push    R19

count_ms:
    ldi     R19,        ( 0xFF & ( OneMS>>16 ) ) ; it is 0 but we need 3byte counter for timing purpose
    ldi     R18,        ( 0xFF & ( OneMS>> 8 ) )
    ldi     R17,        ( 0xFF &   OneMS       )

delay_1ms:
    subi    R17,        1   ; 1 clock tick
    sbci    R18,        0   ; 1 clock tick
    sbci    R19,        0   ; 1 clock tick
    brcc    delay_1ms       ; 2 clock ticks when jumps, 1 when it does not

    dec     R3
    brne    count_ms

    pop     R19
    pop     R18
    pop     R17

    pop     R16
    out     _SFR_IO_ADDR(SREG),     R16
    pop     R16
    ret



; either expected by linker, equivalent to the "old style" .ORG 0
; or alternatively generated by the C/C++ compiler on its own accord 
.GLOBAL _start
.TEXT
_start:
    jmp     start
    ; interrupt table would follow *** here *** if there are any interrupt services
    ; 32bits per entry, up to 34 entries

; this is the part of the loader program that initializes the stack etc.
.TEXT
start:
    ldi     R16,                    0xFF && (RAMEND>>8)
    out     _SFR_IO_ADDR(SPH),      R16
    ldi     R16,                    0xFF && RAMEND
    out     _SFR_IO_ADDR(SPL),      R16
    jmp     main
