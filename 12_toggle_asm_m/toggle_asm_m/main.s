#include <avr/io.h> #include "global_defs.inc" .GLOBAL main.EQU LED_alive , 7.EQU LED0 , 0.EQU LED1 , 1.EQU KEY0 , 0.EQU KEY1 , 1.DATAled_status:    .BYTE 1key_last:    .BYTE 1.TEXTmain:main_initialize:;   Optional: zero portD contents to prevent LED flickering during this setup    eor     R16,                        R16    out     _SFR_IO_ADDR(PORTA),        R16;   Using PortD, Pin7 and Pin0 as outputs    ldi     R16,                        (1<<LED_alive | 1<<LED0); Note: if random other LEDs are one, set all connected PINs to output mode - ldi R16, 0xFF    out     _SFR_IO_ADDR(DDRA),         R16;   Reassuring that PortB pin 0 PINB is set as an input with pull up resistors    ldi     R16,                        0    out     _SFR_IO_ADDR(DDRE),         R16         ; sets all pins as IN    ldi     R16,                        1<<KEY0    out     _SFR_IO_ADDR(PORTE),        R16         ; activates pull up resistors on used pins;   Initialize variables and registers    ldi     R16,                        0    sts     led_status,                 R16    sts     key_last,                   R16main_superloop:    ldi     R17,        1<<LED_alive    lds     R16,        led_status    eor     R16,        R17    sts     led_status, R16    in      R16,        _SFR_IO_ADDR(PINE)    lds     R18,        key_last    eor     R18,        R16    sts     key_last,   R16check_b0:    mov     R16,        R18    andi    R16,        1<<KEY0    breq    skip_b0    lds     R16,        key_last    andi    R16,        1<<KEY0    breq    skip_b0toggle_led0:    ldi     R17,        1<<LED0    lds     R16,        led_status    eor     R16,        R17    sts     led_status, R16skip_b0:    lds     R16,        led_status    out     _SFR_IO_ADDR(PORTA),    R16        ; call delay function with number of MS in R3    ldi     R16,        100    mov     R3,         R16    rcall   delay_in_ms    rjmp    main_superloop